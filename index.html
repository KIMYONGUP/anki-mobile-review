<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Anki Blue - 26::02::18</title>
<style>
:root {
  --bg: #ffffff;
  --surface: #f8f9fa;
  --card-bg: #ffffff;
  --text: #1a1a2e;
  --text-light: #6c757d;
  --border: #dee2e6;
  --primary: #0a8cdb;
  --b1-color: #f0ad4e;
  --b1-bg: #fff8e1;
  --b2-color: #d9534f;
  --b2-bg: #fce4ec;
  --b3-color: #8e44ad;
  --b3-bg: #f3e5f5;
  --cloze-hidden-bg: #e3f2fd;
  --cloze-hidden-text: #0a8cdb;
  --shadow: 0 2px 8px rgba(0,0,0,0.08);
}

@media (prefers-color-scheme: dark) {
  :root {
    --bg: #1a1a2e;
    --surface: #16213e;
    --card-bg: #1e2a45;
    --text: #e8e8e8;
    --text-light: #a0a0a0;
    --border: #2d3748;
    --primary: #4dabf7;
    --b1-color: #ffc107;
    --b1-bg: #3d3200;
    --b2-color: #ff6b6b;
    --b2-bg: #3d1515;
    --b3-color: #cc99ff;
    --b3-bg: #2d1a3d;
    --cloze-hidden-bg: #1a3a5c;
    --cloze-hidden-text: #4dabf7;
    --shadow: 0 2px 8px rgba(0,0,0,0.3);
  }
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: var(--bg);
  color: var(--text);
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  -webkit-user-select: none;
  user-select: none;
}

.header {
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  padding: 12px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}

.header-title {
  font-size: 15px;
  font-weight: 600;
  color: var(--primary);
}

.header-date {
  font-size: 13px;
  color: var(--text-light);
}

.progress-bar {
  height: 3px;
  background: var(--border);
  flex-shrink: 0;
}

.progress-fill {
  height: 100%;
  background: var(--primary);
  transition: width 0.3s ease;
}

.card-area {
  flex: 1;
  min-height: 0;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  touch-action: pan-y;
  padding: 16px;
}

.card {
  background: var(--card-bg);
  border-radius: 12px;
  padding: 24px 20px;
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
  box-shadow: var(--shadow);
  border: 1px solid var(--border);
  font-size: 17px;
  line-height: 1.7;
  word-break: keep-all;
  overflow-wrap: break-word;
}

.card-meta {
  font-size: 11px;
  color: var(--text-light);
  margin-bottom: 12px;
  display: flex;
  gap: 8px;
}

.cloze {
  display: inline;
  padding: 2px 6px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
}

.cloze.b1.hidden { background: var(--b1-bg); color: var(--b1-color); }
.cloze.b2.hidden { background: var(--b2-bg); color: var(--b2-color); }
.cloze.b3.hidden { background: var(--b3-bg); color: var(--b3-color); }

.cloze.revealed {
  color: white;
  padding: 2px 8px;
}

.cloze.b1.revealed { background: var(--b1-color); }
.cloze.b2.revealed { background: var(--b2-color); }
.cloze.b3.revealed { background: var(--b3-color); }

.cloze .hint {
  font-size: 0.85em;
  opacity: 0.7;
}

.controls {
  background: var(--surface);
  border-top: 1px solid var(--border);
  padding: 12px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
  gap: 10px;
}

.nav-btn {
  background: var(--primary);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 10px 20px;
  font-size: 15px;
  font-weight: 500;
  cursor: pointer;
  min-width: 70px;
  transition: opacity 0.2s;
}

.nav-btn:active {
  opacity: 0.7;
}

.nav-btn:disabled {
  opacity: 0.3;
  cursor: default;
}

.counter {
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
  min-width: 60px;
  text-align: center;
}

.reveal-btn {
  background: none;
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px 14px;
  font-size: 13px;
  color: var(--text-light);
  cursor: pointer;
}

.reveal-btn:active {
  background: var(--border);
}
</style>
</head>
<body>

<div class="header">
  <span class="header-title">Anki Blue</span>
  <span class="header-date">26::02::18</span>
</div>
<div class="progress-bar"><div class="progress-fill" id="progress"></div></div>

<div class="card-area" id="cardArea">
  <div class="card" id="card"></div>
</div>

<div class="controls">
  <button class="nav-btn" id="prevBtn" onclick="navigate(-1)">&larr;</button>
  <button class="reveal-btn" id="revealBtn" onclick="toggleAll()">Show All</button>
  <span class="counter" id="counter">1/1</span>
  <button class="nav-btn" id="nextBtn" onclick="navigate(1)">&rarr;</button>
</div>

<script>
const cards = [{"deck": "life of pi", "text": "that made the animal glow, as if with a fever. I {{b1::prepared for}} my end. For nothing. It started running in {{b2::circles}} again.\nWhen an animal decides to do something, it can do it for a very long time. All morning the hyena ran in circles going yip yip yip yip yip. {{c1::Once in a while}} it brieﬂy stopped at the stern bench, but {{b3::otherwise}} every lap was {{c1::identical}} to the {{c1::previous}} one, {{c1::with no variations in}} movement, {{c1::in}} speed, {{c1::in}} the pitch or the volume of the yipping, {{c1::in}} the {{c1::counter-clockwise direction::반시계방향}} of travel. Its yipping was shrill and annoying in the extreme. It became so tedious and draining to watch that I eventually turned my head to the side, trying to keep guard with the corner of my eyes. Even the zebra, which at", "tags": ["a::1", "Q", "marked", "26::02::18"]}, {"deck": "life of pi", "text": "동기화 확인3.5 확인", "tags": ["b::2", "marked", "26::02::18"]}, {"deck": "life of pi", "text": "{{b1::dd}}", "tags": ["26::02::18", "marked"]}, {"deck": "dd", "text": "that made the animal glow, as if with a fever. I {{b2::prepared for}} my end. For nothing. It started running in {{b1::circles}} again.\nWhen an animal decides to do something, it can do it for a very long time. All morning the hyena ran in circles going yip yip yip yip yip. {{b1::Once in a while}} it brieﬂy stopped at the stern bench, but {{b3::otherwise}} every lap was {{c1::identical}} to the {{b3::previous}} one, {{b1::with no variations in}} movement, {{b1::in}} speed, {{b1::in}} the pitch or the volume of the yipping, {{b1::in}} the {{b1::counter-clockwise direction::반시계방향}} of travel. Its yipping was shrill and annoying in the extreme. It became so tedious and draining to watch that I eventually turned my head to the side, trying to keep guard with the corner of my eyes. Even the zebra, which at", "tags": ["26::02::18"]}];
let currentIndex = 0;
let revealedState = {};

const clozePattern = /\{\{(b[1-3])::(.*?)(?:::(.*?))?\}\}/g;

function parseClozes(text) {
  let result = '';
  let lastIndex = 0;
  let clozeIndex = 0;
  const regex = new RegExp(clozePattern.source, 'g');
  let match;

  while ((match = regex.exec(text)) !== null) {
    // 텍스트 중 매치 이전 부분 (줄바꿈을 <br>로 변환)
    result += escapeHtml(text.slice(lastIndex, match.index));
    const type = match[1];
    const answer = match[2];
    const hint = match[3] || '';
    const key = currentIndex + '-' + clozeIndex;
    const isRevealed = revealedState[key];

    if (isRevealed) {
      result += '<span class="cloze ' + type + ' revealed" data-idx="' + clozeIndex + '">' + escapeHtml(answer) + '</span>';
    } else {
      const display = hint ? '<span class="hint">[' + escapeHtml(hint) + ']</span>' : '[...]';
      result += '<span class="cloze ' + type + ' hidden" data-idx="' + clozeIndex + '">' + display + '</span>';
    }
    lastIndex = regex.lastIndex;
    clozeIndex++;
  }
  result += escapeHtml(text.slice(lastIndex));
  return result;
}

function escapeHtml(str) {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\n/g, '<br>');
}

function renderCard() {
  if (cards.length === 0) return;
  const c = cards[currentIndex];
  const cardEl = document.getElementById('card');

  let meta = '<div class="card-meta"><span>' + escapeHtml(c.deck) + '</span>';
  const tags = c.tags.filter(t => !(/^\d{2}::\d{2}::\d{2}$/).test(t));
  if (tags.length > 0) {
    meta += '<span>' + tags.map(t => '#' + t).join(' ') + '</span>';
  }
  meta += '</div>';

  cardEl.innerHTML = meta + '<div class="card-text">' + parseClozes(c.text) + '</div>';

  // cloze 터치 토글
  cardEl.querySelectorAll('.cloze').forEach(el => {
    el.addEventListener('click', function(e) {
      e.stopPropagation();
      const idx = parseInt(this.dataset.idx);
      const key = currentIndex + '-' + idx;
      revealedState[key] = !revealedState[key];
      renderCard();
    });
  });

  // 카운터 & 프로그레스
  document.getElementById('counter').textContent = (currentIndex + 1) + '/' + cards.length;
  document.getElementById('progress').style.width = ((currentIndex + 1) / cards.length * 100) + '%';
  document.getElementById('prevBtn').disabled = (currentIndex === 0);
  document.getElementById('nextBtn').disabled = (currentIndex === cards.length - 1);
}

function navigate(dir) {
  const newIndex = currentIndex + dir;
  if (newIndex >= 0 && newIndex < cards.length) {
    currentIndex = newIndex;
    renderCard();
  }
}

function toggleAll() {
  const c = cards[currentIndex];
  const regex = new RegExp(clozePattern.source, 'g');
  let match;
  let idx = 0;
  let allRevealed = true;

  while ((match = regex.exec(c.text)) !== null) {
    const key = currentIndex + '-' + idx;
    if (!revealedState[key]) allRevealed = false;
    idx++;
  }

  // 전체 토글
  regex.lastIndex = 0;
  idx = 0;
  while ((match = regex.exec(c.text)) !== null) {
    revealedState[currentIndex + '-' + idx] = !allRevealed;
    idx++;
  }
  renderCard();
}

// 스와이프
let touchStartX = 0;
let touchStartY = 0;
document.getElementById('cardArea').addEventListener('touchstart', function(e) {
  touchStartX = e.changedTouches[0].screenX;
  touchStartY = e.changedTouches[0].screenY;
});
document.getElementById('cardArea').addEventListener('touchend', function(e) {
  const dx = e.changedTouches[0].screenX - touchStartX;
  const dy = e.changedTouches[0].screenY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 50) {
    if (dx < 0) navigate(1);   // 왼쪽 스와이프 → 다음
    else navigate(-1);          // 오른쪽 스와이프 → 이전
  }
});

// 키보드
document.addEventListener('keydown', function(e) {
  if (e.key === 'ArrowLeft') navigate(-1);
  else if (e.key === 'ArrowRight') navigate(1);
  else if (e.key === ' ') { e.preventDefault(); toggleAll(); }
});

renderCard();
</script>
</body>
</html>